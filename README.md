# MSSQL_Integrations
Система синхронизации и репликации данных между различными таблицами (и их представлениями) и базами данных.

Эта небольшая система состоит из:
- таблицы:
  - **DataObject** - описывает источник, приемник и опции обмена данными с рамках общего контекста (объекта данных)
  - **DataAttributes** - описывает колонки на стороне источника и приемника в рамках каждого объекта данных
  - **Log** - короткий журнал для записи запускаемых синхронизаций
  - **LogDetails** - журнал с деталями по каждой строке данных, которая была изменена в ходе синхронизации
- хранимые процедуры и функции:
  - **usp_generate** - собрать и получить скрипт с командой MERGE. Эта функция сама по себе не содержит полностью работающий скрипт. Её результат "дорабатывается" процедурой usp_runIntegration.
  - **usp_runIntegration** - запустить синронизацию конкретного объекта данных. Результат работы будет записан в таблицы Log и LogDetails.

## Пример настройки и запуска

Есть два сервера СУБД MSSQL на разных компьютерах:
- server1. Источник, генерирующий данные.
- server2. Потребитель данных источника.
Задача: синхронизировать данные, т.е. передавать их из таблицы на server1 в таблицу server2.

### Установка MSSQL_Integrations

Запустить скрипт MSSQL_Integrations.sql на server2. Этот скрипт создаст БД Integrations. В дальнейшем вся настройка будет выполняться в этой БД.

### Настройка

Сначала владелец или администратор server1 должен предоставить информацию для подключения к server1: адрес сервера, имя экземпляра, порт и т.д. Кроме этого необходимо получить название БД, таблицы (детальные описания колонок) и соответствующие права чтения.

Например, мы хотим реплицировать следующую таблицу из БД testdb на стороне источника:
```
create table Test (
	i int identity primary key, 
	ts datetime default (getdate()), 
	txt nvarchar(max)
);
insert into Test select 'Hello, ';
insert into Test select 'World!';
```

На принимающей стороне таблица должна иметь аналогичную структуру, но **БЕЗ ОГРАНИЧЕНИЙ** колонок.
```
create table Test (
	i int, 
	ts datetime, 
	txt nvarchar(max)
);
```

На основе полученной информации на server2 создается объект linked server, реализующий подключение к server1. Дадим ему название testls. Роль источника может играть любая другая СУБД, к которой MSSQL потенциально может подключаться: PostgreSQL, Oracle, Firebird и т.д. Также необязательно использовать linked server. В качестве промежуточного звена могут использоваться команды openrowset или openquery. Или синхронизация может выполняться внутри самой СУБД.

Потом в конфигурационной таблице дается общее описание объекта данных:
```
insert into dbo.DataObject(name,SourceName,DestinationName) 
values ('Test','[testls].[testdb].[dbo].[test]','[import].[dbo].[test]');
```

затем необходимо описать колонки, которые надо запрашивать:
```
insert into dbo.DataAttributes(DataObject_id, SourceName,DestinationName,IsUnique,IsTimestamp)
values (1, 'i','i', 1, 0), (1, 'ts','ts', 0, 1), (1, 'txt','txt', 0, 0)
```

Метка **IsUnique** необходима для того, чтобы с помощью уникальности ключевых атрибутов отбросить дубликаты записей, если они есть на стороне источника. Иначе команда MERGE вернет исключение.

Метка **IsTimestamp** необходима для того, чтобы ограничить запрос данных определенным временным интервалом. Иначе запрос данных будет возвращать ВСЕ записи из источника.

Должно быть как минимум по одной колонке с меткой IsUnique и IsTimestamp.

### Запуск

Для запуска интеграции используется хранимая процедура:
```
exec usp_runIntegration 1
```

В таблицах Log и LogDetails содержится вся информация о ходе интеграции. Если возникла ошибка, то в целях отладки можно получить текст всего сгенерированного скрипта импорта данных:
```
exec usp_runIntegration 1, @verbose = 1
```
